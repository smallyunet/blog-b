<!-- Stable asset version (for cache busting without full-site churn)--><!DOCTYPE html><html lang="zh-cn"><head><title>BitDoge</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><!-- Mobile viewport: include viewport-fit=cover to allow CSS safe-area usage on full-screen devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"><!-- iOS Safari / PWA status bar style (use default so text stays legible on light background)--><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><!-- SEO basics--><meta name="description"><!-- Open Graph & Twitter--><link rel="canonical" href="https://b.smallyu.net/2026/01/20/BitDoge/"><meta property="og:title" content="BitDoge"><meta property="og:type" content="article"><meta property="og:url" content="https://b.smallyu.net/2026/01/20/BitDoge/"><meta property="og:site_name" content="smallyu的博客（B 面）"><meta name="twitter:card" content="summary_large_image"><!-- Browser UI color--><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0f1115"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><!-- stylesheets--><!-- Use a stable, configurable asset version to prevent full-site churn on every build.--><!-- Set `asset_version` in theme _config.yml when you actually change CSS/JS.--><link rel="stylesheet" href="/css/xcode.min.css?v=v1.1"><link rel="stylesheet" href="/css/post.css?v=v1.1"><!-- unified typography overrides for both home and post pages--><link rel="stylesheet" href="/css/typography.css?v=v1.1"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu的博客（B 面）" type="application/atom+xml">
</head><body><div><div class="inner"><h1>BitDoge</h1><div class="time">2026-01-20</div><div class="title-margin"></div><p>BitDoge 是一个部署在以太坊主网（Chain ID&#x3D;1）的 ERC-20 代币，按照这样的规则运行：</p>
<ol>
<li>代币名称：BitDoge (BITDOGE)</li>
<li>代币合约地址：<a href="https://etherscan.io/address/0x000000001994bb7b8ee7d91012bdecf5ec033a7f"><code>0x000000001994bb7b8ee7d91012bdecf5ec033a7f</code></a></li>
<li>代币的总供应量是 2100 万，没有初始流通量</li>
<li>代币的释放规则是，每一个以太坊区块最多产生 1 BitDoge</li>
<li>获取代币的方式是，每次向代币的合约地址转账 0 ETH，就可以获得 1 BitDoge</li>
<li>转账的金额可以大于 0 ETH，但是不会因为带有金额而获得更多 BitDoge，仍然只能得到 1 BitDoge。而且转账的金额会被永久锁定在合约内，无法取出</li>
<li>合约中没有任何 Owner 权限，也没有其他特殊权限，<a href="https://etherscan.io/address/0x000000001994bb7b8ee7d91012bdecf5ec033a7f#code">合约源码</a> 已经在 Etherscan 验证</li>
<li>代币的创世区块（Genesis Block）是以太坊的区块高度 <a href="https://etherscan.io/block/24444444">24444444</a>（2026年2月12日），在此之前合约会拒绝交易</li>
<li>每一个区块的代币奖励是 1 BitDoge，每 4 年减半一次，也就是 10512000 个以太坊区块之后，每个区块只能获得 0.5 BitDoge</li>
<li>如果当前区块没有地址交互，代币奖励会打入黑洞地址 <a href="https://etherscan.io/address/0x000000000000000000000000000000000000dEaD"><code>0x000000000000000000000000000000000000dEaD</code></a></li>
<li>每一个区块只有第一个与合约交互的地址可以获得代币奖励</li>
<li>按照每 4 年一次的减半周期，BitDoge 的区块奖励大概会在 140 年之后（2166年）归零</li>
</ol>
<p>合约源码全文：</p>
<pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import &#123;ERC20&#125; from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;

/**
 * @title BitDoge (The 140-Year Social Experiment)
 * @notice A deflationary token that rigorously simulates Bitcoin&#39;s halving mechanics on Ethereum.
 * @dev 
 * - Total Supply: 21,000,000 (Strict Cap)
 * - Block Time: ~12 seconds (Ethereum)
 * - Halving: Every ~4 years (10,512,000 blocks)
 * - Mechanism: 
 * 1. Pure PVP: First come, first served per block. No Cooldowns. No Limits.
 * 2. Entropy Rule: If a block is missed (no interaction), its reward is BURNED forever.
 * 3. Genesis Launch: Mining is strictly locked until block #24,444,444.
 */
contract BitDoge is ERC20 &#123;
    // ==========================================
    //              COSMIC CONSTANTS
    // ==========================================

    // Strict cap: 21 Million coins.
    uint256 public constant MAX_SUPPLY = 21000000 * 1e18; 
    
    // Initial reward: 1 Coin per block.
    // Ethereum produces ~7200 blocks/day. 
    // This matches Bitcoin&#39;s early issuance (~7200 BTC/day) perfectly.
    uint256 public constant INITIAL_REWARD = 1 * 1e18;
    
    // Halving interval: ~4 Years (based on 12s block time).
    uint256 public constant HALVING_BLOCKS = 10512000; 
    
    // Standard burn address (The Black Hole).
    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;

    // ==========================================
    //           GENESIS CONFIGURATION
    // ==========================================

    // The Sequence of Death and Entropy.
    // Mining starts precisely at this block height.
    // Approx. 23 days from now (based on current height ~24.27M).
    uint256 public constant GENESIS_BLOCK = 24444444; 

    // ==========================================
    //              STATE VARIABLES
    // ==========================================

    // Tracks the last block that was processed (mined or burned).
    uint256 public lastMinedBlock;       
    
    // Total ETH sacrificed to the contract (forever locked).
    // Serves as the &quot;floor value&quot; or monument of the experiment.
    uint256 public totalSacrificed; 

    // ==========================================
    //                 EVENTS
    // ==========================================

    event Minted(address indexed user, uint256 userReward, uint256 burnedReward, uint256 blockNumber);
    event Sacrifice(address indexed user, uint256 amount);

    /**
     * @dev Constructor
     * Sets the state pointers. No parameters needed as Genesis is hardcoded.
     */
    constructor() ERC20(&quot;BitDoge&quot;, &quot;BITDOGE&quot;) &#123;
        require(GENESIS_BLOCK &gt; block.number, &quot;Genesis must be in the future&quot;);
        
        // Initialize state so the first valid mineable block is GENESIS_BLOCK
        lastMinedBlock = GENESIS_BLOCK - 1; 
    &#125;

    /**
     * @dev Main interaction point. 
     * Send 0 ETH (to just mint) or sacrifice ETH (to mint + donate).
     * WARNING: No Cooldowns. No Max ETH Limits. Pure Gas War.
     */
    receive() external payable &#123;
        // 1. Genesis Check: Is it time yet?
        require(block.number &gt;= GENESIS_BLOCK, &quot;BitDoge loading... Wait for Block #24444444!&quot;);

        // 2. Competition Check: Has this block already been mined?
        // Only one winner per block.
        require(block.number &gt; lastMinedBlock, &quot;Block already mined&quot;);
        
        // 3. Bot Protection: Only allow EOAs (Externally Owned Accounts).
        // This prevents smart contracts from batch-mining, ensuring fairness.
        require(msg.sender == tx.origin, &quot;Humans only&quot;);
        
        // 4. Hard Cap Check.
        require(totalSupply() &lt; MAX_SUPPLY, &quot;Minting ended (Year 2160+)&quot;);

        _processMining(msg.sender, msg.value);
    &#125;

    /**
     * @dev Internal logic to calculate rewards and burns.
     */
    function _processMining(address user, uint256 ethAmount) internal &#123;
        // --- Step 1: Calculate Current Reward Rate ---
        // Based on time passed since Genesis.
        uint256 blocksPassed = block.number - GENESIS_BLOCK;
        uint256 era = blocksPassed / HALVING_BLOCKS; 
        
        // Bitwise shift for halving. Returns 0 after 64 halvings.
        uint256 currentRate = (era &gt;= 64) ? 0 : (INITIAL_REWARD &gt;&gt; era);

        // --- Step 2: Distribute Rewards ---
        
        // A. User Reward: 
        // The user only gets the reward for the CURRENT block.
        uint256 userReward = currentRate;
        
        // B. Black Hole Reward (Entropy):
        // All blocks missed between the last mine and now are burned.
        // &quot;Use it or lose it.&quot;
        uint256 missedBlocks = block.number - lastMinedBlock - 1;
        uint256 burnReward = missedBlocks * currentRate;
        
        // --- Step 3: Supply Cap Protection ---
        uint256 totalRequired = userReward + burnReward;
        if (totalSupply() + totalRequired &gt; MAX_SUPPLY) &#123;
            uint256 remaining = MAX_SUPPLY - totalSupply();
            
            // Priority given to the user. Burn the rest.
            if (remaining &lt;= userReward) &#123;
                userReward = remaining;
                burnReward = 0;
            &#125; else &#123;
                burnReward = remaining - userReward;
            &#125;
        &#125;

        // --- Step 4: Update State ---
        lastMinedBlock = block.number;
        
        // Handle ETH Sacrifice (locked forever)
        if (ethAmount &gt; 0) &#123;
            totalSacrificed += ethAmount;
            emit Sacrifice(user, ethAmount);
        &#125;

        // --- Step 5: Minting ---
        if (userReward &gt; 0) &#123;
            _mint(user, userReward);
        &#125;
        
        // Direct mint to Dead address (Auto-Burn)
        if (burnReward &gt; 0) &#123;
            _mint(BURN_ADDRESS, burnReward);
        &#125;

        emit Minted(user, userReward, burnReward, block.number);
    &#125;
&#125;
</code></pre>
</div></div></body><!-- Defer non-critical scripts for better performance--><script defer src="/js/jquery.min.js?v=v1.1"></script><script defer src="/js/highlight.min.js?v=v1.1"></script><script defer src="/js/main.js?v=v1.1"></script><script defer src="/js/lightbox.js?v=v1.1"></script><script defer src="/js/bootstrap.min.js?v=v1.1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-DK569K62F7"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DK569K62F7');</script></html>